#include "balinx_parser.hpp"
#include <sstream>
#include <iostream>

BalinxParser::BalinxParser(const std::string& filename) : file_(filename) {}

bool BalinxParser::parse() {
    if(!file_.is_open()) {
        return false;
    }

    std::string line;
    while(getline(file_, line)) {
        if(line.empty() || line[0] == '#') {
            continue;
        }
        
        std::istringstream iss(line);
        std::string token;
        if(std::getline(iss, token)) {
            if(token == "version") {
                if(!handle_version(line)) {
                    return false;
                }
            }
            else if (token == "executable") {
                if(!handle_executable(line)) {
                    return false;
                }
            }
        }
    }
    return true;
}

bool BalinxParser::handle_version(const std::string& line) {
    std::string version_str = line.substr(line.find(':') + 1);
    std::vector<int> version_nums;
    std::istringstream iss(version_str);
    std::string token;
    while(std::getline(iss, token, '.')) {
        int version_num;
        if(std::istringstream(token) >> version_num) {
            version_nums.push_back(version_num);
        }
        else {
            return false;
        }
    }
    if(version_nums.empty()) {
        return false;
    }

    version_number_ = std::move(version_nums);
    return true;

}

bool BalinxParser::handle_executable(const std::string& line) {
    executable_name_ = line.substr(line.find(':') + 1);
    executable_name_.erase(0, executable_name_.find_first_not_of(" \t")); //Trim leading whitespace
    return !executable_name_.empty();
}


